package latencyinteractionexperiment;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.LMemCommandStream;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Params;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.DelimiterMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingInput;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

import displaystandards.DisplayStandard;


public class MemoryCommandGeneratorKernel extends Kernel {

	protected MemoryCommandGeneratorKernel(KernelParameters parameters, DisplayStandard display) {
		super(parameters);

		//DFEVar start_of_frame = io.input("frame_sync_in", dfeBool());

		flush.disabled();

		NonBlockingInput<DFEVar> sof =
			io.nonBlockingInput("frame_sync_in", dfeBool(), constant.var(true), 1, DelimiterMode.FRAME_LENGTH, 0, NonBlockingMode.NO_TRICKLING);

		DFEVar start_of_frame = sof.valid & sof.data;

		DFEVar length = io.scalarInput("FrameSizeBursts", dfeUInt(32));

		/* Generate commands to read a frame from memory.
		 * The following code creates a counter, that will count up from 0-the final address of the plane in burst sizes, and then stop.
		 * The DFEVar valid, will indicate when the counter is counting up (because the count will be less than the final address), and this is
		 * used to add new commands to the stream.
		 * When a new frame begins, the counter is reset and the process repeats.
		 *  */

		Params burst_counter_params =  control.count.makeParams(32)
													.withMax(length)
													.withWrapMode(WrapMode.STOP_AT_MAX)
													.withReset(start_of_frame);

		Counter burst_counter = control.count.makeCounter(burst_counter_params);

		DFEVar offset = io.scalarInput("BurstOffset", dfeUInt(32));

		LMemCommandStream.makeKernelOutput(
				"memory_commands",
				burst_counter.getCount() < (length - 1),
				(burst_counter.getCount() + offset).cast(dfeUInt(28)),
				constant.var(dfeUInt(8),1),
				constant.var(dfeUInt(7),1),
				constant.var(dfeUInt(4),0),
				constant.var(false));

	}


}
