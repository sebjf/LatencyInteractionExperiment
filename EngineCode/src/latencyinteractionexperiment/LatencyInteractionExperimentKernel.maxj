package latencyinteractionexperiment;

import java.util.ArrayList;

import maxvideo.MaxVideoKernel;
import types.FragmentInput;
import types.fRGBA;
import types.uRGB;
import types.uRGBA;

import com.maxeler.maxcompiler.v0.utils.MathUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.LMemCommandStream;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Params;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.DelimiterMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingInput;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;

import displaystandards.DisplayStandard;
import functions.ColourFunctions;

class LatencyInteractionExperimentKernel extends MaxVideoKernel {

	protected LatencyInteractionExperimentKernel(KernelParameters parameters) {
		super(parameters, DisplayStandard.make_1280x1024x75());
	}

	@Override
	public uRGB ComputePixelColour(FragmentInput input) {
		// TODO Auto-generated method stub

		Plane background = new Plane("plane_0", Display, input);

		uRGB background_colour = new uRGB(background.getColour());

		ArrayList<Sprite> spriteList = new ArrayList<Sprite>();

		spriteList.add(new Sprite("sprite_0", 256, 256));
		spriteList.add(new Sprite("sprite_1", 256, 256));
		spriteList.add(new Sprite("sprite_2", 256, 256));

		for(Sprite s : spriteList){
			fRGBA sc = s.getColour(input, this);
			background_colour = new uRGB(ColourFunctions.Blend(sc, new fRGBA(background_colour)));
		}

		return background_colour;
	}

	public class Plane
	{
		public Plane(String name, DisplayStandard display, FragmentInput input)
		{
			NonBlockingInput<DFEStruct> content =
				io.nonBlockingInput(name + "_content", uRGBA.getDFEStructType(), constant.var(true), 1, DelimiterMode.FRAME_LENGTH, 0, NonBlockingMode.NO_TRICKLING);
			m_colourdata = content.data;

			int frame_size_in_bytes = display.TotalWidth * display.TotalHeight * (uRGBA.getDFEStructType().getTotalBits() / 8);
			int frame_size_in_bursts = (frame_size_in_bytes / 384) - 1;

			int number_of_pixels = display.TotalWidth * display.TotalHeight;

			/* Generate commands to read a frame from memory.
			 * The following code creates a counter, that will count up from 0-the final address of the plane in burst sizes, and then stop.
			 * The DFEVar valid, will indicate when the counter is counting up (because the count will be less than the final address), and this is
			 * used to add new commands to the stream.
			 * When a new frame begins, the counter is reset and the process repeats.
			 *  */

			Params burst_counter_params =  control.count.makeParams(MathUtils.bitsToRepresent(frame_size_in_bursts))
														.withMax(frame_size_in_bursts)
														.withWrapMode(WrapMode.STOP_AT_MAX)
														.withReset(input.m_start_of_frame);

			Counter burst_counter = control.count.makeCounter(burst_counter_params);


			DFEVar pixel_counter = control.count.simpleCounter(MathUtils.bitsToRepresent(number_of_pixels), number_of_pixels);

			int pixels_per_burst = 384/4;

			DFEVar ready = KernelMath.modulo(pixel_counter, pixels_per_burst).eq(0);
			DFEVar address = (pixel_counter / pixels_per_burst);
			DFEVar real_address = pixel_counter.eq(0) ? constant.var(0) : address;

			LMemCommandStream.makeKernelOutput(name + "_commands",
					ready,
					real_address.cast(dfeUInt(28)),
			//		burst_counter.getCount() < frame_size_in_bursts,
			//		burst_counter.getCount().cast(dfeUInt(28)),
					constant.var(dfeUInt(8),1),
					constant.var(dfeUInt(7),1),
					constant.var(dfeUInt(4),0),
					constant.var(false));

		}

		private final DFEStruct m_colourdata; //without data.valid this will be nonsense sometimes, but we will have a max under-run of 96 pixels, which will be off screen anyway

		fRGBA getColour()
		{
			return new fRGBA(m_colourdata);
		}

	}

	public class Sprite
	{
		public class spritePropertiesStructType extends DFEStructType	{
			public spritePropertiesStructType()	{
				super(sft("x",dfeUInt(32)),
					  sft("y",dfeUInt(32)),
					  sft("R",dfeUInt(8)),
					  sft("G",dfeUInt(8)),
					  sft("B",dfeUInt(8)),
					  sft("A",dfeUInt(8)),
					  sft("padding",dfeUInt(32)));
			}
		}

		private final int m_width;
		private final int m_height;
		private final Memory<DFEStruct> m_spriteContent;
		private final DFEStruct m_properties;

		Sprite(String name, int width, int height)
		{
			this.m_width = width;
			this.m_height = height;
			m_spriteContent = mem.alloc(uRGB.getDFEStructType(), width * height );

			NonBlockingInput<DFEStruct> positions =
				io.nonBlockingInput(name + "_positions", new spritePropertiesStructType(), constant.var(true),
						1, DelimiterMode.FRAME_LENGTH, 0, NonBlockingMode.NO_TRICKLING);
			m_properties = Reductions.streamHold(positions.data, positions.valid);


			NonBlockingInput<DFEStruct> content =
				io.nonBlockingInput(name + "_content", uRGBA.getDFEStructType(), constant.var(true), 1, DelimiterMode.FRAME_LENGTH, 0, NonBlockingMode.NO_TRICKLING);

			CounterChain pc = control.count.makeCounterChain(content.valid);
			DFEVar writeAddress = pc.addCounter(m_width * m_height, 1);

			uRGB casted_colour = new uRGB(content.data);

			m_spriteContent.write(writeAddress - 1, casted_colour.getDFEStruct(), content.valid);

		}

		fRGBA getColour(FragmentInput input, LatencyInteractionExperimentKernel kernel)
		{
			DFEVar x = m_properties["x"];
			DFEVar y = m_properties["y"];
			DFEVar x_offset = input.m_x.cast(dfeUInt(32)) - x;
			DFEVar y_offset = input.m_y.cast(dfeUInt(32)) + y;
			DFEVar readAddress = ((y_offset * m_width) + x_offset).cast(dfeUInt(MathUtils.bitsToAddress(m_width * m_height)));

			DFEVar isValid = (x_offset >= 0) & (x_offset < m_width) & (y_offset >= 0) & (y_offset < m_height);
			DFEStruct colour = isValid.cast(dfeBool()) ?  m_spriteContent.read(readAddress) : uRGB.Black(kernel).getDFEStruct();

			uRGB masked_colour = new uRGB(colour);
			DFEStruct expanded_colour = masked_colour.Equals(uRGB.Black(kernel)) ? fRGBA.Transparent(kernel).getDFEStruct() : new fRGBA(masked_colour).getDFEStruct();

			return ColourFunctions.Multiply(new fRGBA(expanded_colour), new fRGBA(m_properties));
		}

	}


}
